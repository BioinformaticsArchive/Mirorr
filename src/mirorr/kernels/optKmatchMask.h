const std::string newKmatchString =
"#ifndef __OPENCL_VERSION__ //defined by the kernel compiler\n"
"#define __kernel\n"
"#define __global\n"
"#define CLK_LOCAL_MEM_FENCE\n"
"#define CLK_GLOBAL_MEM_FENCE\n"
"#define uint unsigned int\n"
"#define size_t unsigned int\n"
"#endif\n"
"\n"
"// define NO_COMPUTE if you want to measure only the memory access\n"
"\n"
"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"\n"
"/**\n"
" *\n"
" * --- WARNING ---\n"
" * The .h version of this file is generated from the .cl file. You\n"
" * MUST run convertCl2Header.sh after any modification to the .cl file!\n"
" * --- WARNING ----\n"
" *\n"
" *\n"
" * Code by Maciej Golebiewski, 13 Jun 2014, and David Rivest-Henault, 15 Mar 2015\n"
" * \n"
" * Copyright (c) 2009-15 CSIRO. All rights reserved.\n"
" * \n"
" * For complete copyright, license and disclaimer of warranty\n"
" * information see the LICENSE.txt file for details.\n"
" * \n"
" * This software is distributed WITHOUT ANY WARRANTY; without even\n"
" * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
" * PURPOSE.  See the above copyright notice for more information.\n"
" * \n"
" */\n"
"\n"
"\n"
"/* Parallel sum across a work group, using a share vector in local memory\n"
" * This kernel is only called from newKmatch, not directly from host.\n"
" *\n"
" * @param n number of work items (threads) in work group\n"
" * @param t serial/1D local index of this work item in its work group\n"
" * @param rblock vector of n elements in local memory, shared across work group\n"
" *\n"
" * The result is in rblock[0]; if work items other than the first one (with t==0)\n"
" * want to access the result they need to call memory fence first after parsum returns.\n"
" */\n"
"__kernel\n"
"inline void parsum(const int n, const int t, double iv, __local double *rblock) {\n"
"\n"
"	double s = iv;\n"
"	int i;\n"
"\n"
"	for (i = n/2; i > 0; i = i/2) {\n"
"		if (t >= i) rblock[t] = s;\n"
"		barrier (CLK_LOCAL_MEM_FENCE);\n"
"		if (t < i) s += rblock[t+i];\n"
"	}\n"
"	if (t == 0) rblock[t] = s;\n"
"\n"
"} // parsum\n"
"\n"
"\n"
"// voxel offset; must allow for negative values\n"
"// to represent voxel outside (to the left of) image\n"
"typedef signed int voff_t;\n"
"\n"
"\n"
"__kernel\n"
"void optKmatch (\n"
"	__read_only image3d_t imgL,\n"
"	__read_only image3d_t imgR,\n"
"	__read_only image3d_t imgML,\n"
"    __read_only image3d_t imgMR,\n"
"    __global uint * kmatches, volatile __global float* scores,__global float* scores2nd,\n"
"    __local double *rblock,\n"
"    __local double *d1vec,\n"
"    __local unsigned int *m1vec,\n"
"    const uint w, const uint h, const uint d,\n"
"    const uint BlockWidth,  const uint NhoodWidth,  const uint padding,\n"
"    const uint BlockGap, const uint NhoodGap,\n"
"    const uint padx, const uint pady, const uint padz)\n"
"{\n"
"	const float EPS = 1e-10;\n"
"	const sampler_t sampler = CLK_FILTER_NEAREST | CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_NONE;\n"
"\n"
"	int4   pxl;	    // temp coords variable for calling read_imagef\n"
"	//float4 ImA;         // value of my pixel in the starting image\n"
"	float4 ImB;         // value of my pixel in the matching block\n"
"	uint4  ImM;	    // value of my pixel in the mask image\n"
"	uint4  ImN;	    // value of my mask in the next matching block\n"
"\n"
"	size_t wgdim[3];    // dimensions of the work group\n"
"	size_t myblock0[3]; // 3D pixel coords of first pixel in starting block\n"
"\n"
"	size_t mypixel[3];  // which pixel in a block this work item is responsible for?\n"
"\n"
"	// to allow for negative coords\n"
"	voff_t nhood0[3];   // 3D pixel coords of first pixel in first matching block\n"
"	voff_t nhood1[3];   // 3D pixel coords of first pixel in last matching block\n"
"\n"
"	// to allow for negative coords\n"
"	voff_t nblock0[3];  // 3D pixel coords of first pixel in matching block\n"
"\n"
"  //double   moyg;  // mean for starting image block\n"
"  double   moyd;  // mean for matching image block\n"
"	double   d1, d1sqr;\n"
"	double   d2, d2sqr;\n"
"	double   d1d2prod;\n"
"	double   baseSearchProd;\n"
"	double   baseSumSqr;\n"
"	double   searchSumSqr;\n"
"\n"
"	double	score;\n"
"\n"
"	float   bestscore = -3.0f;\n"
"	float   secondBest = -3.0f;\n"
"\n"
"	size_t slid, snum, mybase;\n"
"\n"
"	voff_t nhood2; // half pixel length of neighbourhood\n"
"\n"
"	uint    bestMatch = 0;\n"
"\n"
"	uint	block_index, ln_off;\n"
"\n"
"	int	i;\n"
"\n"
"	// length of neighbourhood edge in pixels\n"
"	nhood2 = (voff_t)((NhoodWidth-1)*BlockGap + BlockWidth)/2;\n"
"\n"
"	for (i = 0; i < 3; i++) {\n"
"\n"
"		// get coords of my block in starting image\n"
"		myblock0[i] = get_group_id(i);\n"
"\n"
"		// get my pixel offsets in a block\n"
"		mypixel[i] = get_local_id(i);\n"
"\n"
"		// dimensions of my work group\n"
"		wgdim[i] = get_local_size(i);\n"
"	}\n"
"\n"
"	// linear index of my block for storing result in the output vectors\n"
"	block_index = myblock0[2]*get_num_groups(1)*get_num_groups(0) + myblock0[1]*get_num_groups(0) + myblock0[0];\n"
"\n"
"	for (i = 0; i < 3; i++) {\n"
"		// compute coords of first pixel in my block\n"
"		// convert block coords to coords of first pixel in block\n"
"		myblock0[i] = myblock0[i] * NhoodGap;\n"
"	}\n"
"\n"
"	myblock0[0] += padx;\n"
"	myblock0[1] += pady;\n"
"	myblock0[2] += padz;\n"
"\n"
"	for (i = 0; i < 3; i++) {\n"
"		// compute coords of first pixel in matching neighborhood\n"
"		// (may fall outside image)\n"
"		nhood0[i] = (voff_t)(myblock0[i] + (BlockWidth/2))-nhood2;\n"
"	}\n"
"\n"
"	// serial local index in working group\n"
"	mybase = mypixel[1]*wgdim[0] + mypixel[2]* wgdim[0]*wgdim[1];\n"
"	slid = mypixel[0] + mybase;\n"
"	// total number of pixels in a block (or work items in a group)\n"
"	snum = wgdim[0]*wgdim[1]*wgdim[2];\n"
"\n"
"	if (slid == 0) {\n"
"		scores[block_index] = -1.0;\n"
"		scores2nd[block_index] = -2.0;\n"
"		kmatches[block_index] = (uint)0;\n"
"	}\n"
"\n"
"	// read and remember the value of my pixel in the starting image\n"
"	pxl.x = myblock0[0] + mypixel[0];\n"
"	pxl.y = myblock0[1] + mypixel[1];\n"
"	pxl.z = myblock0[2] + mypixel[2];\n"
"	const float4 ImA = read_imagef(imgL, sampler, pxl);\n"
"	ImM = read_imageui(imgML, sampler, pxl);\n"
"  \n"
"	// parallel sum across work group to compute\n"
"	// meang of starting image block\n"
"	parsum(snum, slid, ImA.s0, rblock);\n"
"	barrier (CLK_LOCAL_MEM_FENCE);\n"
"	// mean for my starting block image\n"
"	const double moyg = rblock[0] / snum;\n"
"\n"
"  d1 = ImA.s0 - moyg;\n"
"\n"
"	// save d1 in shared memory for re-use by other work items\n"
"	// when computing d1d2prod\n"
"	d1vec[slid] = d1;\n"
"  /*\n"
"	// compute and remember base sum square\n"
"	d1sqr = d1 * d1\n"
"  */\n"
"  m1vec[slid] = ImM.s0;\n"
"\n"
"	// compute neighbourhood boundaries for the 3 dimensions\n"
"	for (i = 0; i < 3; i++) {\n"
"		// end boundary\n"
"		nhood1[i] = nhood0[i] + BlockGap * (NhoodWidth - 1);\n"
"		// adjust start boundary to inside the image\n"
"		for (; nhood0[i] < 0; nhood0[i] += BlockGap) ;\n"
"	}\n"
"\n"
"	// ensure end boundaries are inside the image\n"
"	nhood1[0] = (nhood1[0] < w-BlockWidth) ? nhood1[0] : w-BlockWidth;\n"
"	nhood1[1] = (nhood1[1] < h-BlockWidth) ? nhood1[1] : h-BlockWidth;\n"
"	nhood1[2] = (nhood1[2] < d-BlockWidth) ? nhood1[2] : d-BlockWidth;\n"
"\n"
"	// z coord of the first layer/slice\n"
"	pxl.z = nhood0[2] + mypixel[2];\n"
"\n"
"	// loop over all layers of the matching neighbourhood\n"
"	for (nblock0[2] = nhood0[2]; nblock0[2] <= nhood1[2]; nblock0[2] += BlockGap) {\n"
"\n"
"		// y coord of the first row in the current layer\n"
"		pxl.y = nhood0[1] + mypixel[1];\n"
"\n"
"		// loop over all rows of the matching neighbourhood\n"
"		for (nblock0[1] = nhood0[1]; nblock0[1] <= nhood1[1]; nblock0[1] += BlockGap) {\n"
"\n"
"			// x coord of the first column in the current row\n"
"			pxl.x = nhood0[0] + mypixel[0];\n"
"\n"
"			// pixels in the first block read by all work items\n"
"			ImB = read_imagef(imgR, sampler, pxl);\n"
"			ImN = read_imageui(imgMR, sampler, pxl);\n"
"\n"
"			// loop over all columns of the matching neighbourhood\n"
"			// (same as moving matching block along the row)\n"
"			for (nblock0[0] = nhood0[0]; nblock0[0] <= nhood1[0]; nblock0[0] += BlockGap) {\n"
"\n"
"				// is my pixel outside the current matching block?\n"
"				if (pxl.x < nblock0[0]) {\n"
"					// yes, calculate new pixel coord\n"
"					pxl.x += BlockWidth;\n"
"					// and read new value\n"
"					ImB = read_imagef(imgR, sampler, pxl);\n"
"					ImN = read_imageui(imgMR, sampler, pxl);\n"
"				}\n"
"\n"
"				// linear offset of my current pixel relative to start of the current\n"
"				// matching block\n"
"				// (used to find d1 (and inMaskL) corresponding to d2 for my current pixel)\n"
"				ln_off = pxl.x - nblock0[0] + mybase;\n"
"\n"
"				// apply mask here by setting {d1sqr, d2sqr, d1d2prod} to 0.0 if out of the mask\n"
"        const bool inMaskL = (m1vec[ln_off] != 0);\n"
"        const bool inMaskR = (ImN.s0 != 0);\n"
"		    const bool inMask  = inMaskL && inMaskR;\n"
"\n"
"				// parallel sum across work group to compute\n"
"				// meang of matching image block\n"
"        barrier (CLK_LOCAL_MEM_FENCE);\n"
"				parsum(snum, slid, ImB.s0, rblock);\n"
"				barrier (CLK_LOCAL_MEM_FENCE);\n"
"				moyd = rblock[0] / snum;\n"
"\n"
"				//d1 = inMask ? ImA.s0 - moyg : 0.;\n"
"        d1 = inMask ? d1vec[ln_off] : 0.;\n"
"        d2 = inMask ? ImB.s0 - moyd : 0.;\n"
"          \n"
"				// compute baseSumSqr, searchSumSqr and baseSearchProd\n"
"        d1sqr = d1 * d1;\n"
"				d2sqr = d2 * d2;\n"
"				d1d2prod = d1 * d2;\n"
"        \n"
"        barrier (CLK_LOCAL_MEM_FENCE);\n"
"\n"
"				// parallel sum across work group to compute\n"
"				// baseSumSqr\n"
"				parsum(snum, slid, d1sqr, rblock);\n"
"				barrier (CLK_LOCAL_MEM_FENCE);\n"
"				baseSumSqr = rblock[0];\n"
"\n"
"				// parallel sums across work group to compute\n"
"				// searchSumSqr\n"
"				parsum(snum, slid, d2sqr, rblock);\n"
"				barrier (CLK_LOCAL_MEM_FENCE);\n"
"				searchSumSqr = rblock[0];\n"
"\n"
"				// parallel sums across work group to compute\n"
"				// baseSearchProd\n"
"				parsum(snum, slid, d1d2prod, rblock);\n"
"				barrier (CLK_LOCAL_MEM_FENCE);\n"
"				baseSearchProd = rblock[0];\n"
"\n"
"				// to avoid branches all work items in work group\n"
"				// compute score but only the first work item in\n"
"				// each group will store the result after the loops\n"
"				score = (baseSumSqr <= EPS || searchSumSqr <= EPS) ?\n"
"					-2.0 :\n"
"				(float) (baseSearchProd * baseSearchProd / baseSumSqr / searchSumSqr);\n"
"				score = score < 3.3e33 ? score : -2.f;\n"
"\n"
"				// keep per workgroup best score and best match\n"
"				if (score > bestscore) {\n"
"					secondBest = bestscore;\n"
"					bestscore = score;\n"
"					// host code expects index of first voxel in block;\n"
"					// not block index\n"
"					// index/offset of the first voxel in the block\n"
"					bestMatch = (uint)(nblock0[2]*w*h + nblock0[1]*w + nblock0[0]);\n"
"				}\n"
"				else {\n"
"					secondBest = (secondBest > score) ? secondBest : score;\n"
"				}\n"
"\n"
"			} // x dimension\n"
"\n"
"			// advance to next row\n"
"			pxl.y += BlockGap;\n"
"\n"
"		} // y dimension\n"
"\n"
"		// advance to next layer\n"
"		pxl.z += BlockGap;\n"
"\n"
"	} // z dimension\n"
"  \n"
"  barrier (CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// store the best score in result vectors\n"
"	if (slid == 0) {\n"
"		scores[block_index] = (float) bestscore;\n"
"		scores2nd[block_index] = (float) secondBest;\n"
"		kmatches[block_index] = bestMatch;\n"
"	}\n"
"\n"
"\n"
"} // optKmatch\n"
;
