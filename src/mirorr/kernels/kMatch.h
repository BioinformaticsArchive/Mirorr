const std::string kMatchString =
"#ifndef __OPENCL_VERSION__ //defined by the kernel compiler\n"
"#define __kernel\n"
"#define __global\n"
"#define CLK_LOCAL_MEM_FENCE\n"
"#define CLK_GLOBAL_MEM_FENCE\n"
"#define uint unsigned int\n"
"#define size_t unsigned int\n"
"#endif\n"
"\n"
"/**\n"
" *\n"
" * --- WARNING ---\n"
" * The .h version of this file is generated from the .cl file. You\n"
" * MUST run convertCl2Header.sh after any modification to the .cl file!\n"
" * --- WARNING ----\n"
" *\n"
" *\n"
" * Code by Jeremy Coatelen, 11 Apr 2011\n"
" * Commented and edited by D Rivest-Henault, 31 Jan 2013\n"
" * \n"
" * * Copyright (c) 2009-15 CSIRO. All rights reserved.\n"
" * \n"
" * For complete copyright, license and disclaimer of warranty\n"
" * information see the LICENSE.txt file for details.\n"
" * \n"
" * This software is distributed WITHOUT ANY WARRANTY; without even\n"
" * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
" * PURPOSE.  See the above copyright notice for more information.\n"
" * \n"
" */\n"
" \n"
" \n"
"/**\n"
" * kMatch:\n"
" * This OpenCL kernel ...\n"
" *\n"
" * @param imgL Base image buffer\n"
" * @param imgR Search image buffer\n"
" * @param meanL Input mean buffer for the inputL image\n"
" * @param meanR Input mean buffer for the inputR image\n"
" * @param varL Input variance buffer for the inputL image\n"
" * @param varR Input variance buffer for the inputR image\n"
" * @param kmatches Output buffer to store the best matches\n"
" * @param scores Output buffer to store the score of the best matches\n"
" * @param scores Output buffer to store the score of the 2nd best matches\n"
" * @param w Width of the base image buffer\n"
" * @param h Height of the base image buffer\n"
" * @param d Depth of the base image buffer\n"
" * @param BlockWidth size of the {2,3}D block\n"
" * @param NhoodWidth size of the neighbourhood to search of correspondences\n"
" * @param padding -- not used\n"
" * @param BlockGap\n"
" */\n"
"//__attribute__((vec_type_hint(float4)))\n"
"//#pragma OPENCL EXTENSION cl_amd_printf : enable\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"__kernel\n"
"void kMatch(\n"
"    __global float * imgL,          __global float * imgR,\n"
"    __global float * meanL,         __global float * meanR,\n"
"    __global float * varL,          __global float * varR,\n"
"    __global uint * kmatches, volatile __global uint * scores,__global uint * scores2nd,\n"
"    const uint w, const uint h, const uint d,\n"
"    uint BlockWidth,  uint NhoodWidth,  uint padding,\n"
"    uint BlockGap)\n"
"{\n"
"  const float EPS = 1e-10;\n"
"\n"
"  // Gpu parameters\n"
"  int     ig          = get_global_id(0);\n"
"  size_t  gsize       = get_global_size(0);\n"
"\n"
"  // Internal variables\n"
"  float   score       = 0.0f;\n"
"  int     i;\n"
"  int     j;\n"
"  int     k;\n"
"  int     r;\n"
"  int     s;\n"
"  int     t;\n"
"  int     r2;\n"
"  int     s2;\n"
"  int     t2;\n"
"  int     jp;\n"
"  int     n;\n"
"  int     tmp;\n"
"  float   v1;\n"
"  float   v2;\n"
"  float   imR1Val;\n"
"  float   imR2Val;\n"
"  float   bestscore   = 0.0f;\n"
"  uint    bestMatch   = 0;\n"
"  uint    old;\n"
"  uint    mask;\n"
"  uint  * iflip;\n"
"\n"
"  // Algorithm parameters\n"
"  int     wh          = w * h;\n"
"  int     BlockWidth2 = BlockWidth*BlockWidth;\n"
"  int     NhoodWidth2 = NhoodWidth*NhoodWidth;\n"
"  int     BlockWidth3 = BlockWidth2*BlockWidth;\n"
"  int     NhoodWidth3 = NhoodWidth2*NhoodWidth;\n"
"  int     Qi          = w * h * d;\n"
"  int     idivs       = ig % Qi;                        // Current voxel position\n"
"  int     jdivs       = ig / Qi;                        // Current part neighbourhood division\n"
"  int     Qneigh      = NhoodWidth3;\n"
"  int     Divs        = (int)((float)gsize / (float)Qi);\n"
"          Divs        = (Divs < Qneigh) ? Divs : Qneigh;\n"
"  int     dQ          = Qneigh / Divs;\n"
"  int     limit       = Divs * Qi;\n"
"\n"
"  // Debug variables\n"
"  int     dbgI        = 67;\n"
"  int     dbgJ        = 107;\n"
"  int     dbgK        = 67;\n"
"  int     dbgJdivs    = 0;\n"
"  int     arg         = 0;\n"
"  int     dbgR        = 9;\n"
"  int     dbgS        = 42;\n"
"  int     dbgT        = 14;\n"
"#if 0\n"
"  float   moyg;\n"
"  float   moyd;\n"
"  float   d1;\n"
"  float   d2;\n"
"  float   baseSearchProd  = 0.0f;\n"
"  float   baseSumSqr      = 0.0f;\n"
"  float   searchSumSqr    = 0.0f;\n"
"#else\n"
"  double   moyg;\n"
"  double   moyd;\n"
"  double   d1;\n"
"  double   d2;\n"
"  double   baseSearchProd  = 0.0f;\n"
"  double   baseSumSqr      = 0.0f;\n"
"  double   searchSumSqr    = 0.0f;\n"
"#endif\n"
"\n"
"#if 0\n"
"  int foundInfinity = 0;\n"
"  int foundInfinity2 = 0;\n"
"  int foundInfinity3 = 0;\n"
"  int foundInfinity4 = 0;\n"
"#endif\n"
"\n"
"  if(ig < limit)\n"
"  {\n"
"    // Set the global indexes\n"
"    r = idivs % wh;\n"
"    i = r % w;\n"
"    j = r / w;\n"
"    k = idivs / wh;\n"
"\n"
"    // initialize the best match\n"
"    bestMatch = (uint) (k * wh + j * w + i); //DRH: bestMatch == idivs\n"
"\n"
"    // Check the edges\n"
"    if (!(i > w - BlockWidth || j > h - BlockWidth\n"
"        || (d > 1 && (k > d - BlockWidth)))) //DRH: uint bug if {w,h,d} < BlockWidth\n"
"    {\n"
"      // Processing on 2D images\n"
"      if (d == 1)\n"
"      {\n"
"        // For each point in the neighbourhood that the kernel\n"
"        // has to threat\n"
"        baseSearchProd = 0.0f;\n"
"        baseSumSqr = 0.0f;\n"
"        searchSumSqr = 0.0f;\n"
"        for (jp = jdivs * dQ; jp < (jdivs + 1) * dQ; ++jp)\n"
"        {\n"
"          // Set the moving indexes in the neigh\n"
"          tmp = jp % NhoodWidth2;\n"
"          r = i + BlockGap * (tmp % NhoodWidth - NhoodWidth / 2);\n"
"          s = j + BlockGap * (tmp / NhoodWidth - NhoodWidth / 2);\n"
"          // Compute the moving values\n"
"          // get the mean\n"
"          score = 0.0f;\n"
"          moyd = meanR[s * w + r];\n"
"          moyg = meanL[j * w + i];\n"
"          // Work on the current block centered on r,s,t\n"
"          for (n = 0; n < BlockWidth2; ++n)\n"
"          {\n"
"            // Set the moving indexes in the block of the current neigh point\n"
"            tmp = n % BlockWidth2;\n"
"            r2 = i + tmp % BlockWidth;\n"
"            s2 = j + tmp / BlockWidth;\n"
"            d1 = imgL[s2 * w + r2] - moyg;\n"
"\n"
"            r2 = r + tmp % BlockWidth;\n"
"            s2 = s + tmp / BlockWidth;\n"
"            d2 = imgR[s2 * w + r2] - moyd;\n"
"            baseSearchProd += d1 * d2;\n"
"            baseSumSqr += d1 * d1;\n"
"            searchSumSqr += d2 * d2;\n"
"          }\n"
"          // compute the normalized score (DRH: squared Normalized Cross-Correlation)\n"
"          score =\n"
"              (baseSumSqr <= EPS || searchSumSqr <= EPS) ?\n"
"                  -2.f :\n"
"                  baseSearchProd * baseSearchProd / baseSumSqr / searchSumSqr;\n"
"          // do we keep the match ?\n"
"          if (score > bestscore)\n"
"          {\n"
"            bestscore = score;\n"
"            bestMatch = (uint) (s * w + r);\n"
"          }\n"
"        }\n"
"      }\n"
"      // Processing on 3D images\n"
"      else\n"
"      {\n"
"        // Compute the fixed values\n"
"        // get the mean\n"
"        //moyg  = meanL[k * wh + j * w + i];\n"
"        //d1    = fabs(imgL[k * wh + j * w + i] - moyg);\n"
"        // get the standard deviation\n"
"        //v1    = sqrt(varL[k * wh + j * w + i]);\n"
"        // Check if the fixed point is good enough\n"
"        // we can check with a median variance here\n"
"        //if ( v1 != 0.0f )\n"
"        //{\n"
"        // For each point in the neighbourhood that the kernel\n"
"        // has to threat\n"
"        for (jp = jdivs * dQ; jp < (jdivs + 1) * dQ; ++jp)\n"
"        {\n"
"          // Set the moving indexes in the neigh\n"
"          tmp = jp % NhoodWidth2;\n"
"          r = i + ((int)BlockGap) * ((int)(tmp % NhoodWidth) - (int)(NhoodWidth / 2));\n"
"          s = j + ((int)BlockGap) * ((int)(tmp / NhoodWidth) - (int)(NhoodWidth / 2));\n"
"          t = k + ((int)BlockGap) * ((int)(jp / NhoodWidth2) - (int)(NhoodWidth / 2));\n"
"\n"
"          if ( (r<0) || (r > w - BlockWidth) ||\n"
"               (s<0) || (s > h - BlockWidth) ||\n"
"               (t<0) || (t > d - BlockWidth) ) {\n"
"            continue; //DRH - block outside the image domain\n"
"          }\n"
"\n"
"          // Compute the moving values\n"
"          // get the mean\n"
"          score = 0.0f;\n"
"          moyd = meanR[t * wh + s * w + r];\n"
"          moyg = meanL[k * wh + j * w + i];\n"
"\n"
"          /* // - - - - - - - - - -\n"
"          // DRH - compute double precision means - to remove:\n"
"          // - - - - - - - - - -\n"
"          double d_moyd = 0., d_moyg = 0.;\n"
"          for (n = 0; n < BlockWidth3; ++n)\n"
"          {\n"
"            tmp = n % BlockWidth2;\n"
"\n"
"            r2 = i + tmp % BlockWidth;\n"
"            s2 = j + tmp / BlockWidth;\n"
"            t2 = k + n / BlockWidth2;\n"
"            d_moyg += imgL[t2 * wh + s2 * w + r2];\n"
"\n"
"            r2 = r + tmp % BlockWidth;\n"
"            s2 = s + tmp / BlockWidth;\n"
"            t2 = t + n / BlockWidth2;\n"
"            d_moyd += imgR[t2 * wh + s2 * w + r2];\n"
"          }\n"
"          moyd = d_moyd / (double)BlockWidth3;\n"
"          moyg = d_moyg / (double)BlockWidth3;\n"
"          // - - - - - - - - - - */\n"
"\n"
"          // Work on the current block centered on r,s,t\n"
"          baseSearchProd = 0.0f;\n"
"          baseSumSqr = 0.0f;\n"
"          searchSumSqr = 0.0f;\n"
"          for (n = 0; n < BlockWidth3; ++n)\n"
"          {\n"
"            tmp = n % BlockWidth2;\n"
"\n"
"            r2 = i + tmp % BlockWidth;\n"
"            s2 = j + tmp / BlockWidth;\n"
"            t2 = k + n / BlockWidth2;\n"
"            d1 = imgL[t2 * wh + s2 * w + r2] - moyg;\n"
"\n"
"            r2 = r + tmp % BlockWidth;\n"
"            s2 = s + tmp / BlockWidth;\n"
"            t2 = t + n / BlockWidth2;\n"
"            d2 = imgR[t2 * wh + s2 * w + r2] - moyd;\n"
"\n"
"            baseSearchProd += d1 * d2;\n"
"            baseSumSqr += d1 * d1;\n"
"            searchSumSqr += d2 * d2;\n"
"          }\n"
"          // compute the normalized score (DRH: squared Normalized Cross-Correlation)\n"
"          score =\n"
"              (baseSumSqr <= EPS || searchSumSqr <= EPS) ?\n"
"                  -2.f :\n"
"                  (float) (baseSearchProd * baseSearchProd / baseSumSqr / searchSumSqr);\n"
"\n"
"          //score = baseSumSqr;\n"
"          //score = moyd; ////DRH DEBUG - GPU-CPU equal\n"
"          //score = searchSumSqr;\n"
"          //score = baseSearchProd;\n"
"\n"
"          //DRH: the above code will sometimes still result in score=Inf due\n"
"          //     to limited float 32 precision, we take care of those here\n"
"          if (score > 3.3e33) {\n"
"            score = -2.f;\n"
"          }\n"
"\n"
"          // do we keep the match ?\n"
"          if (score > bestscore)\n"
"          {\n"
"            bestscore = score;\n"
"            bestMatch = (uint) (t * wh + s * w + r);\n"
"          }\n"
"        }\n"
"        //}\n"
"      }\n"
"    }\n"
"\n"
"\n"
"    // A very good trick to compute the max value of the score\n"
"    // on all the kernels directly (with float values) !\n"
"    // DRH: Create a 32bits uint representation of any 32bits floating point number.\n"
"    //      This representation preserves ordering.\n"
"    iflip = (uint*) &bestscore;\n"
"    mask = -(int) ((*iflip) >> 31) | 0x80000000;\n"
"    mask = (*iflip) ^ mask;\n"
"\n"
"#if 0\n"
"    // DRH: Check for infinity (due to limited float precision)\n"
"    if (mask == 4286578688U) {\n"
"      mask = 3212836864U; // == 1.0f\n"
"      //mask = 2147483648; // == 0.f\n"
"    }\n"
"#endif\n"
"\n"
"    //old = atom_max(&scores[idivs], mask);\n"
"    //barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    old = atom_max(&scores[idivs], mask);\n"
"    barrier(CLK_GLOBAL_MEM_FENCE);\n"
"    uint drh = scores[idivs];\n"
"\n"
"    // If this kernel has the best score, the score is saved and\n"
"    //if (old < mask)\n"
"    if ( (drh == mask) && (old != mask) )\n"
"    {\n"
"      // we save the match (there should only have one update following the barrier)\n"
"      kmatches[k * wh + j * w + i] = (uint) bestMatch;\n"
"      //kmatches[k * wh + j * w + i] = (uint) (1001 * wh + 2 * w + 1);\n"
"      //kmatches[k * wh + j * w + i] = (uint) (1001 * wh + s * w + r);\n"
"      //kmatches[k * wh + j * w + i] = (uint) (t * wh + s * w + r);\n"
"      //scores2nd[k * wh + j * w + i] = (uint) old;\n"
"      atom_max(&scores2nd[idivs], old);\n"
"    }\n"
"    else //if we don't have the best, maybe we have the 2nd best\n"
"    {\n"
"      atom_max(&scores2nd[idivs], mask);\n"
"    }\n"
"\n"
"    /*DRH - useless?\n"
"    if ((int) scores2nd[k * wh + j * w + i] == 0)\n"
"    {\n"
"      scores2nd[k * wh + j * w + i] = (uint) 1069547519; //Flag value == -3.f when converted as above\n"
"    }*/\n"
"  }\n"
"}\n"
;
