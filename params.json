{"name":"Mirorr","tagline":"Multimodal Image Registration using blOck-matching and Robust Regression","body":"Mirorr is a software developed at [The Australian E-Health Research Centre](http://aehrc.com/) for **3D rigid/affine** medical image registration that implements a **robust** and **inverse-consistent** algorithm. Mirror is a command line application that is relatively easy to use. Being robust, it is suitable for both **mono- and multi-modal** applications. Inverse-consistency means that transform computed from image A to image B is **precisely the inverse** of the one computed from image B to image A. That means that it is not necessary to manage situation like the one illustrated below, simplifying your pipeline.\r\n\r\n![Non inverse-consistent registration](images/fig1.png)\r\n\r\nMore formally, Mirorr implements a robust multimodal image registration method that is based on local correlations computed using a block-matching approach. Both rigid and affine transformation models are available. By default, Mirorr benefits from a half-way space definition and is inverse-consistent for most practical purposes. That means that the order of input images on the command line has a notably reduced effect on the end result, simplifying analysis, reducing opportunities for user error, and increasing robustness. This algorithm has been extensively tested for CT-MR, MR-MR and MR-PET registrations, using pelvis and head/brain datasets. An experimental GPU implementation is available. \r\n\r\nThis software has been developed by [David Rivest-Hénault](https://github.com/drhenault), [Nick Dowson](http://baconmockup.com/600/800/), and a team of researchers from [CSIRO](http://www.csiro.au/)'s [The Australian E-Health Research Centre](http://aehrc.com/), see AUTHORS.txt for more details, and is made available under the terms of a liberal open source license, see LICENSE.txt.\r\n\r\nThis is the main web page for CSIRO Mirorr. \r\n\r\n\r\nCONTENTS\r\n========\r\n\r\n- [REFERENCE AND CITATION](http://aehrc.github.io/Mirorr/#reference-and-citation)\r\n- [LICENSE](http://aehrc.github.io/Mirorr/#license)\r\n- [BUILDING THE PROGRAM](http://aehrc.github.io/Mirorr/#building-the-program)\r\n- [USER MANUAL AND EXAMPLES](http://aehrc.github.io/Mirorr/#user-manual-and-examples)\r\n- [FREQUENTLY ASKED QUESTIONS (FAQ)](http://aehrc.github.io/Mirorr/#frequently-asked-questions-faq)\r\n- [REPORTING AN ISSUE](reporting-an-issue)\r\n\r\n\r\nREFERENCE AND CITATION\r\n======================\r\n\r\nMirorr is the reference implementation for the _Mirror_ & _SymMirorr_ methods described in:\r\n\r\nDavid Rivest-Hénault, Nicholas Dowson, Peter B. Greer, Jurgen Fripp, and Jason Dowling. **\"Robust inverse-consistent affine CT-MR registration in MRI-assisted and MRI-alone prostate radiation therapy.\"** Medical Image Analysis (In press), 2015. DOI: [10.1016/j.media.2015.04.014](http://dx.doi.org/10.1016/j.media.2015.04.014). Article available at [ScienceDirect](http://authors.elsevier.com/sd/article/S136184151500064X).\r\n\r\nThe permanent citable DOI link to the original source code used in the production of this paper is here: [dx.doi.org](http://dx.doi.org/10.4225/08/55372DE407418). The GitHub version has been updated and is (semi-)actively developed. \r\n\r\nIf you use this program for scientific research or other related work, we would appreciate if you could cite the paper and/or the code DOI mentioned above.\r\n\r\n\r\nLICENSE\r\n=======\r\n\r\nCopyright (c) 2009-15 CSIRO. All rights reserved.\r\n\r\nFor complete copyright, license and disclaimer of warranty information see LICENSE.txt file for details.\r\n\r\nThis software is distributed WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the above copyright notice for more information.\r\n\r\n\r\nBUILDING THE PROGRAM\r\n====================\r\n\r\nThe README.md (a simple text file) contains detailed build instructions. Briefly, this software uses a regular CMake build. The following packages need to be installed to build Mirorr:\r\n\r\n - [CMake](http://www.cmake.org/).\r\n - [ITK](http://www.itk.org/). Version v4.X recommended (tested with: 4.1.0 to 4.7.1).\r\n - [Boost](http://www.boost.org/). At the minimum you needs the following components: `program_options filesystem system timer`\r\n - If you want to use the GPU implementation, you need a working OpenCL development installation (generally provided by NVIDIA CUDA or the ATI equivalent).\r\n\r\nWith any modern operating system, there should be no need to build these packages since they are readily available through your favourite package manager (I'm partial to apt-get).\r\n\r\n\r\nUSER MANUAL AND EXAMPLES\r\n========================\r\n\r\nImportant usage note\r\n--------------------\r\n\r\nThe **Mirorr** program implements two methods described in the original paper: _Mirorr_ and _SymMirorr_. Generally, you will want to use _SymMirorr_, which is the default behaviour of **Mirorr** (we acknowledge that this can be a bit counter-intuitive).\r\n\r\nIf you really want to use the non inverse-consistent _Mirorr_, run the program as follows:\r\n```bash\r\nmirorr --reg-mode classic [other program arguments]\r\n```\r\nOtherwise, to use _SymMirorr_, run the program as follows:\r\n```bash\r\nmirorr --reg-mode symmetric [other program arguments]  # or simply:\r\nmirorr [other program arguments]\r\n```\r\n\r\nGetting help\r\n------------\r\n\r\nMirorr as a relatively extensive help page, and this is where you should start searching:\r\n```bash\r\nmirorr --help\r\n```\r\nIf you can't find what you're looking for, feel free to contact the corresponding author indicated in the paper.\r\n\r\n\r\nVery quick start\r\n----------------\r\n\r\nThere are two minimal examples provided in the test directory. You can run them to validate your build, and read the .sh file to get some inspiration.\r\n\r\n```bash\r\ncd ../test; \r\n./test.sh\r\n./test-gpu.sh  # Will crash if your build has not been compiled with OpenCL support.\r\n```\r\n\r\n\r\nFREQUENTLY ASKED QUESTIONS (FAQ)\r\n================================\r\n\r\n- **Mirorr is slow.** Did you forget to define the CMake variable CMAKE_BUILD_TYPE to Release (CMAKE_BUILD_TYPE=Release)? Typical speedup is about 8x. In addition, you can double check that the program is really using all available CPU cores (or ask for more cores on the cluster). It is possible to make the program use a specific number of cores with --nthreads.\r\n\r\n- **Mirorr is still slow.** Sometimes, the two highest resolution settings of the image pyramid can be vastly redundant. You can try to remove one with the -b and -c options.\r\n\r\n- **I want more speed.** If you have a GPU that supports OpenCL (most recent NVIDIA or ATI), you can try our GPU implementation. Compile the program with (USE_OPENCL=ON) and turn on GPU by using the --use-gpu-bm switch.\r\n\r\n\r\nREPORTING AN ISSUE\r\n==================\r\n\r\nAlthough the developers are perfect, the source code might not be so. If you encounter an issue, please report it in the [GitHub Page](https://github.com/aehrc/Mirorr) (you need a free GitHub account for that). Alternatively, if you are C++ literate, your can ask for a pull request. I will try to respond quickly. Finally, if none of the above works well for you, feel free to contact the corresponding author indicated in the paper.\r\n\r\n","google":"UA-62172649-1","note":"Don't delete this file! It's used internally to help with page regeneration."}